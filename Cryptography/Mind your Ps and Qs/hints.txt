Decrypt my super sick RSA:
c: 861270243527190895777142537838333832920579264010533029282104230006461420086153423
n: 1311097532562595991877980619849724606784164430105441327897358800116889057763413423
e: 65537

Database
http://factordb.com/index.php?query=1311097532562595991877980619849724606784164430105441327897358800116889057763413423

p*q
=1955175890537890492055221842734816092141 * 670577792467509699665091201633524389157003

m = (p-1)*(q-1)
= 1311097532562595991877980619849724606783491897137083280307201653693412798558164280
e Ã— d = 1 (mod m)
d = e^(-1) mod m

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

credit@ https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python

d = modinv(65537, m)
d = 693529123416505412979446025120625035374876994645029007711823240743237277989774953

Decryption
c^d % n = answer

>>> c = 861270243527190895777142537838333832920579264010533029282104230006461420086153423
>>> d = modinv(65537, m)
>>> n = 1311097532562595991877980619849724606784164430105441327897358800116889057763413423
>>> ans = pow(c,d,n)
>>> print(ans)
 13016382529449106065927291425342535437996222135352905256639573959002849415739773
>>> hex_string = hex(ans)[2:]
>>> bytes_object = bytes.fromhex(hex_string)
>>> ascii_string = bytes_object.decode("ascii")
>>> print(ascii_string)
picoCTF{sma11_N_n0_g0od_13686679}